# Patrones de Diseño

### 1. Patrones Creacionales

| Nombre               | Descripción                                                                                                                                                                                                                                         | Propósito                                                                  | Problema que soluciona                                                                    | Solución                                                                                          | Caso de uso                                                                                         | Caso de no uso                                                                 |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| Factory Method       | Define una interfaz para crear objetos y deja a las subclases decidir la clase a instanciar. Se usa para evitar la instanciación directa en el código cliente.                                                                                      | Permitir la creación delegada de objetos sin acoplarse a clases concretas. | Evitar dependencia fuerte de clases específicas en la creación de objetos.                | Utiliza un método de fábrica que delega la instanciación a subclases.                             | Cuando se requiere flexibilidad para cambiar el tipo de objeto en tiempo de ejecución.              | Si la creación de objetos es trivial y fija.                                   |
| Abstract Factory     | Proporciona una interfaz para crear familias de objetos relacionados sin especificar las clases concretas.                                                                                                                                          | Crear grupos coherentes de objetos relacionados.                           | Dificultades para garantizar la compatibilidad entre productos de una familia.            | Implementa una fábrica abstracta que produce objetos relacionados entre sí.                       | Sistemas multiplataforma o con interfaces intercambiables.                                          | Si sólo se instancia un objeto aislado.                                        |
| Builder              | Separa la construcción de un objeto complejo de su representación, permitiendo construirlo paso a paso.                                                                                                                                             | Facilitar la creación de objetos complejos y configurables.                | Constructores muy largos o con muchos parámetros, lo que dificulta la legibilidad.        | Usa un objeto “builder” que asigna cada parámetro gradualmente y luego construye el objeto final. | Configurar objetos con múltiples parámetros opcionales, como en configuraciones de UI o personajes. | Si el objeto es simple o con pocos parámetros.                                 |
| Prototype            | Caracteriza un objeto mediante la clonación de una instancia ya existente para crear nuevas instancias.                                                                                                                                             | Permitir la duplicación de objetos con configuración compleja.             | Costos elevados en la creación de objetos complejos desde cero.                           | Implementa un método de clonación (profundo o superficial) de un objeto prototipo.                | Copiar configuraciones o estados complejos cuando la creación es costosa.                           | Si cada objeto debe ser único o si la clonación añade complejidad innecesaria. |
| Singleton            | Garantiza que una clase tenga una única instancia a lo largo de la aplicación, proporcionando un punto de acceso global. En lenguajes como Python o JavaScript, se implementa mediante módulos o closures, no solo con métodos estáticos            | Asegurar una única instancia global para un recurso compartido.            | Creación de múltiples instancias de recursos críticos que pueden generar inconsistencias. | Se implementa con un constructor privado y un método estático que devuelve la única instancia.    | Administración de recursos como conexiones a bases de datos o un servicio de logging.               | Si se requiere más de una instancia o afecta la testabilidad.                  |
| Dependency Injection | Inyecta las dependencias de una clase desde el exterior en lugar de crearlas internamente, promoviendo un diseño desacoplado y fácilmente testeable. No es un patrón clásico de GoF, pero se adoptó ampliamente en frameworks como Spring o Angular | Desacoplar la creación de objetos de su uso y facilitar el testing.        | Dificultad para sustituir o modificar dependencias en un código fuertemente acoplado.     | Se inyectan las dependencias a través del constructor, setters o mediante frameworks.             | Aplicaciones complejas donde se requieran cambios rápidos en las dependencias (ej. Spring).         | En sistemas muy simples donde la inyección añade complejidad innecesaria.      |
| Object Pool          | Administra un conjunto de objetos reutilizables para evitar la sobresaturación en la creación y destrucción constante de instancias costosas.                                                                                                       | Reutilizar objetos costosos para mejorar el rendimiento y uso de memoria.  | Altos costos de creación de objetos cuando estos se instancian frecuentemente.            | Mantiene un "pool" o reserva de instancias que se pueden pedir y devolver según sea necesario.    | Conexión a bases de datos, hilos o recursos gráficos donde la creación es intensiva en recursos.    | Si los objetos son baratos de crear o no se usan de forma intensiva.           |

---

### 2. Patrones Estructurales

| Nombre    | Descripción                                                                                                                                                   | Propósito                                                             | Problema que soluciona                                                      | Solución                                                                           | Caso de uso                                                                                  | Caso de no uso                                                                       |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| Adapter   | Permite que clases con interfaces incompatibles trabajen juntas transformando una interfaz en otra que se espera.                                             | Integrar componentes con interfaces diferentes.                       | Incompatibilidad entre la interfaz requerida y la existente.                | Implementa un adaptador que traduce la interfaz de un componente a la esperada.    | Integrar código legado o módulos de terceros con la nueva arquitectura.                      | Si se puede modificar la clase fuente para que sea compatible.                       |
| Bridge    | Separa la abstracción de su implementación, de modo que ambas puedan evolucionar independientemente.                                                          | Reducir el acoplamiento entre abstracción e implementación.           | Acoplamiento rígido que dificulta la extensión de ambas jerarquías.         | Define dos jerarquías separadas y conecta ambas mediante composición.              | Variar de forma independiente la interfaz (abstracción) y su implementación.                 | En sistemas simples donde no se requiera tanta flexibilidad.                         |
| Composite | Permite componer objetos en estructuras de árbol para representar jerarquías parte-todo, permitiendo tratarlos de manera uniforme.                            | Manejar estructuras jerárquicas compuestas.                           | Dificultad para tratar objetos individuales y compuestos de la misma forma. | Define una interfaz común para objetos simples y compuestos, y usa recursión.      | Representar menús, archivos, componentes gráficos u otras estructuras jerárquicas.           | Si los objetos no forman parte de una jerarquía compleja.                            |
| Decorator | Añade responsabilidades o comportamientos adicionales a un objeto de manera dinámica sin alterar su estructura original.                                      | Extender funcionalidad de objetos sin modificar su código base.       | Limitaciones de la herencia para extender funciones de forma flexible.      | Envuelve al objeto original en un decorador que añade la funcionalidad deseada.    | Agregar características extra (por ejemplo, logging o validaciones) a objetos existentes.    | Cuando la herencia simple ya resuelve el problema o se prefiere una solución simple. |
| Facade    | Proporciona una interfaz unificada para un conjunto de interfaces en un subsistema complejo, ocultando su complejidad.                                        | Simplificar el uso de sistemas o librerías complejas.                 | Exposición de mucha complejidad a los clientes de un subsistema.            | Crea una "fachada" que encapsula y simplifica la interacción con el subsistema.    | Ocultar detalles complejos de una API o subsistema en aplicaciones.                          | Si el subsistema ya es suficientemente simple para ser consumido directamente.       |
| Flyweight | Reutiliza objetos compartidos para reducir el consumo de memoria en situaciones con muchos objetos similares.                                                 | Ahorrar recursos mediante la compartición de instancias.              | Uso excesivo de memoria por la creación de muchos objetos similares.        | Crea y administra una única instancia compartida para datos inmutables.            | Interfaces gráficas, edición de texto (caracteres) o cualquier escenario de objetos en masa. | Si los objetos tienen estados únicos y no comparten datos intrínsecos                |
| Proxy     | Intermedia el acceso a un objeto, controlando, registrando o restringiendo sus operaciones.                                                                   | Controlar el acceso a un objeto y añadir funcionalidades adicionales. | Necesidad de proteger o gestionar el acceso a un objeto.                    | Intercepta llamadas al objeto real y añade lógica antes o después de la ejecución. | Implementar caché, seguridad, carga diferida o registro de llamadas.                         | Si no se requiere ningún control o intercepción en el acceso.                        |
| Module    | Organiza y encapsula funcionalidades en unidades independientes y reutilizables. Común en JavaScript/TypeScript para encapsular funcionalidades en namespaces | Facilitar la modularización y separación de responsabilidades.        | Código monolítico difícil de mantener y escalar.                            | Divide la aplicación en módulos independientes con interfaces bien definidas.      | Desarrollo de librerías, SDKs o sistemas de plug-in.                                         | En proyectos muy pequeños donde la división modular genera sobrecomplejidad.         |

---

### 3. Patrones de Comportamiento

| Nombre                  | Descripción                                                                                                                                               | Propósito                                                                         | Problema que soluciona                                                              | Solución                                                                                                             | Caso de uso                                                                                                       | Caso de no uso                                                                  |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| Chain of Responsibility | Permite que múltiples objetos tengan la oportunidad de manejar una solicitud, pasándola a lo largo de una cadena hasta que uno la procesa.                | Desacoplar el emisor de la solicitud de sus receptores.                           | Evitar múltiples condicionales y acoplamiento en el manejo de solicitudes.          | Encadena objetos que intentan procesar la solicitud y la pasan al siguiente si no pueden manejarla.                  | Procesamiento de solicitudes en sistemas de logging o filtros de autenticación.                                   | Si solo hay un único objeto que debe procesar la solicitud.                     |
| Command                 | Encapsula una solicitud o acción en un objeto, permitiendo parametrizar clientes y gestionar operaciones como deshacer/rehacer.                           | Desacoplar la invocación de una acción de su ejecución.                           | El acoplamiento directo entre el invocador y el objeto que ejecuta la acción.       | Representa cada acción como un objeto comando que se puede encolar, ejecutar o revertir.                             | Sistemas de deshacer/rehacer, menús de comandos o colas de tareas en interfaces interactivas.                     | Si las acciones son simples y pueden ejecutarse sin encapsulación adicional.    |
| Interpreter             | Define una representación para un lenguaje y provee un intérprete que utiliza dicha representación para interpretar oraciones en ese lenguaje.            | Permitir la interpretación de un lenguaje o gramática específica.                 | Dificultad para interpretar sentencias de un lenguaje personalizado.                | Modela la gramática del lenguaje mediante clases que representan reglas y expresiones, interpretándolas en conjunto. | Lenguajes de dominio específico (DSL), expresiones matemáticas o validación de fórmulas empresariales (ej: Excel) | Si se puede resolver el problema con expresiones regulares o lógica directa.    |
| Iterator                | Ofrece una forma de acceder secuencialmente a los elementos de una colección sin exponer su estructura interna.                                           | Desacoplar la iteración de la estructura de la colección.                         | Dificultad para recorrer colecciones sin acoplarse a su implementación interna.     | Implementa un objeto iterador que mantiene el estado y recorre la colección de forma controlada.                     | Recorrer estructuras de datos complejas sin conocer su representación subyacente.                                 | Si la colección es sencilla y soporta iteración directa (ej. for-each).         |
| Mediator                | Facilita la comunicación entre múltiples objetos, evitando que se comuniquen directamente entre sí y reduciendo el acoplamiento.                          | Coordinar la comunicación centralizadamente.                                      | Interacción compleja y acoplamiento directo entre componentes.                      | Introduce un mediador que centraliza la comunicación y actúa como intermediario.                                     | Sistemas con múltiples componentes interdependientes, como interfaces de usuario complejas o chats.               | Si la comunicación es sencilla y directa sin riesgo de acoplamiento excesivo.   |
| Memento                 | Captura y externaliza el estado interno de un objeto sin violar su encapsulamiento, permitiendo su restauración posterior.                                | Permitir guardar y restaurar el estado de un objeto.                              | Dificultad para implementar la función de “deshacer” sin exponer detalles internos. | Crea un objeto memento que almacena el estado del objeto para luego restaurarlo sin violar su encapsulamiento.       | Funcionalidades de deshacer/rehacer en editores o sistemas transaccionales.                                       | Si el estado puede ser fácilmente recalculado o si no se necesita restauración. |
| Observer                | Establece una relación uno a muchos entre un objeto sujeto y sus observadores, notificándolos de cambios en el primer objeto.                             | Permitir que varios objetos reaccionen a cambios de otro sin fuerte acoplamiento. | La necesidad de mantener actualizados múltiples objetos ante un cambio.             | Implementa un mecanismo de suscripción en el sujeto y notifica a los observadores en cada cambio.                    | Notificaciones en interfaces, sistemas de eventos o subscripciones a cambios de estado.                           | Si sólo existe una relación estática o la actualización manual es suficiente.   |
| State                   | Permite que un objeto altere su comportamiento cuando cambia su estado interno, como si cambiara de clase.                                                | Encapsular comportamientos específicos según el estado.                           | Uso excesivo de condicionales para manejar diferentes estados de un objeto.         | Separa el comportamiento mediante clases distintas que representan cada estado, permitiendo el cambio dinámico.      | Máquinas de estados en videojuegos o sistemas de flujo de trabajo con múltiples estados.                          | Si el objeto sólo tiene uno o dos estados simples manejables con condicionales. |
| Strategy                | Define una familia de algoritmos intercambiables, encapsulados en clases separadas, permitiendo seleccionar el algoritmo adecuado en tiempo de ejecución. | Permitir cambiar el algoritmo de una operación dinámicamente.                     | Acoplar el cliente a una única implementación de un algoritmo.                      | Implementa una interfaz común para todos los algoritmos y permite intercambiarlos según convenga.                    | Seleccionar dinámicamente métodos de cálculo, validación o estrategias de pago.                                   | Si el algoritmo es fijo y no se requiere variabilidad.                          |
| Template Method         | Define el esqueleto de un algoritmo en un método, dejando algunos pasos a ser implementados por subclases sin alterar la estructura general.              | Estandarizar el flujo de un algoritmo mientras se permite personalización.        | Duplicación de código en algoritmos similares con ligeras variantes.                | Crea un método base que fija la secuencia y permite a las subclases redefinir ciertos pasos.                         | Procesos estandarizados (como generación de reportes) con pasos variabilidad en algunos detalles.                 | Si cada implementación es muy distinta y no comparten una estructura común.     |
| Visitor                 | Permite definir una nueva operación sin cambiar las clases de los elementos sobre los que opera, separando el algoritmo de la estructura de los objetos.  | Añadir operaciones a estructuras de objetos sin modificar las clases.             | Dificultad para agregar nuevos comportamientos sin alterar la jerarquía de clases.  | Implementa un “visitor” que recorre la estructura y ejecuta la operación deseada de forma externa.                   | Procesamiento de estructuras de objetos complejas para operaciones como la serialización o análisis.              | Si las operaciones son pocas o se pueden integrar directamente en los objetos.  |

---

# Arquitecturas de Desarrollo de Software

### 4. Arquitecturas de Software

| Nombre                                       | Descripción                                                                                                                                                                                           | Propósito                                                                                                     | Problema que soluciona                                                              | Solución                                                                                                         | Caso de uso                                                                                               | Caso de no uso                                                               |
| -------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| Monolítica                                   | Toda la aplicación se ejecuta como una única unidad desplegable. Es simple de desarrollar en fases iniciales.                                                                                         | Centralizar la funcionalidad en un solo producto.                                                             | Evitar sobrecomplicación en proyectos pequeños y de bajo tráfico.                   | Combina todas las funcionalidades en una única base de código y despliegue.                                      | Proyectos startups o aplicaciones simples sin alta demanda de escalado.                                   | Sistemas que requieran escalabilidad o despliegue independiente de módulos.  |
| Microservicios                               | Divide la aplicación en servicios pequeños, autónomos y desplegables de forma independiente. Cada servicio se comunica a través de APIs o mensajes.                                                   | Permitir el escalado y mantenimiento independiente de cada servicio.                                          | Los monolitos pueden volverse difíciles de mantener y escalar.                      | Desarrollar cada funcionalidad como un servicio independiente y comunicarlos mediante protocolos estandarizados. | Grandes sistemas con equipos distribuidos y alta demanda de escalabilidad.                                | Proyectos simples donde el overhead de coordinación es innecesario.          |
| Model-View-Controller (MVC)                  | Separa la lógica en tres componentes: modelo (datos), vista (interfaz) y controlador (lógica). Facilita una organización clara y mantenible.                                                          | Separar las responsabilidades en la aplicación para facilitar el mantenimiento.                               | Mezcla de lógica de negocio con la presentación, lo que dificulta el mantenimiento. | Divide el desarrollo en tres áreas claramente diferenciadas que se comunican entre sí.                           | Aplicaciones web tradicionales y de escritorio con interfaces complejas.                                  | Sistemas cuya complejidad no justifica una separación tan estricta.          |
| Model-View-ViewModel (MVVM)                  | Extiende MVC separando la lógica de presentación en un ViewModel que vincula el modelo y la vista. Ideal para mantener la sincronización de datos.                                                    | Facilitar la vinculación de datos entre la interfaz y la lógica de negocio.                                   | Dificultad para sincronizar la vista y los datos de manera reactiva y limpia.       | Implementar un ViewModel que actúe de intermediario entre la vista y el modelo, facilitando la data binding.     | Aplicaciones en WPF, Xamarin o frameworks modernos de JavaScript con data binding.                        | Proyectos sencillos sin necesidad de una sincronización compleja de datos.   |
| Layered Architecture (Arquitectura en Capas) | Organiza el sistema en capas jerárquicas (presentación, lógica de negocio, acceso a datos, etc.). Facilita la separación de responsabilidades.                                                        | Dividir la aplicación en capas con responsabilidades bien definidas.                                          | Acoplamiento de funcionalidades que dificulta su evolución y mantenimiento.         | Implementa un diseño donde cada capa se comunica solo con su capa adyacente superior o inferior.                 | Aplicaciones empresariales en las que la separación de lógica y datos es primordial.                      | Aplicaciones muy simples donde una división en capas resulta innecesaria.    |
| Microkernel (Arquitectura de Plugin)         | Un núcleo mínimo que se extiende mediante módulos o plugins. Permite agregar o modificar funcionalidades sin alterar el núcleo.                                                                       | Proveer un sistema extensible y flexible mediante plugins.                                                    | Dificultad para modificar o ampliar sistemas monolíticos sin afectar el núcleo.     | Establecer un núcleo base con funcionalidades básicas y permitir la integración de plugins independientes.       | Sistemas como IDEs, servidores o aplicaciones que requieren extensibilidad a futuro.                      | Si el sistema no está diseñado para ser extendido o modificado a menudo.     |
| Event-Driven Architecture (EDA)              | Basa la comunicación en eventos, donde los componentes producen y reaccionan a mensajes asíncronos.                                                                                                   | Permitir una comunicación desacoplada y asíncrona entre componentes.                                          | Acoplamiento y lentitud en sistemas con comunicaciones síncronas.                   | Utiliza un bus de eventos o intermediario de mensajes para gestionar la comunicación en tiempo real.             | Sistemas con alta concurrencia o procesamiento en tiempo real, como sistemas de trading o notificaciones. | Si la comunicación síncrona es suficiente para el sistema.                   |
| Domain-Driven Design (DDD)                   | Centra el diseño del software en el dominio y sus reglas, utilizando un lenguaje ubicuo entre analistas y desarrolladores.                                                                            | Alinear la implementación del software con las necesidades del negocio.                                       | Desconexión entre la lógica del negocio y la implementación técnica.                | Modela el dominio a través de entidades, agregados y servicios que reflejen la complejidad del negocio.          | Aplicaciones complejas donde el conocimiento del negocio es clave en la solución.                         | Sistemas sencillos con dominios poco complejos.                              |
| Hexagonal Architecture (Ports and Adapters)  | Separa el núcleo de la aplicación de la infraestructura, permitiendo que la lógica de negocio permanezca aislada de detalles externos.                                                                | Aislar el dominio central de cambios externos e infraestructura variable.                                     | Acoplamiento entre la lógica del negocio y sistemas externos (APIs, BDs).           | Define puertos (interfaces) que conectan el dominio con adaptadores para cada tecnología externa.                | Sistemas que deben probarse de forma aislada y que requieran integraciones diversas.                      | Si la complejidad o el acoplamiento con el exterior es mínimo.               |
| Bulkhead                                     | Aísla componentes críticos en compartimentos independientes para evitar que un fallo se propague a todo el sistema. Usado en microservicios para aislar fallos (ej: limitar CPU/memoria por servicio) | Aumentar la resiliencia del sistema limitando el impacto de fallas aisladas.                                  | Fallos en un componente que afectan en cadena al sistema completo.                  | Divide el sistema en "compartimentos estancos" que se aíslan unos de otros en caso de error.                     | Sistemas distribuidos y microservicios que requieran tolerancia a fallos.                                 | En aplicaciones que no enfrentan riesgos de fallo en cascada.                |
| Bróker (Broker)                              | Centraliza la comunicación entre componentes mediante un intermediario que enruta mensajes entre productores y consumidores.                                                                          | Desacoplar la comunicación directa entre componentes distribuidos.                                            | Difícil integración y comunicación directa entre múltiples servicios.               | Utiliza un intermediario (como RabbitMQ o Kafka) para gestionar la mensajería y enrutamiento.                    | Sistemas de mensajería en tiempo real y arquitecturas orientadas a eventos.                               | Si la comunicación directa resulta suficiente y eficiente.                   |
| API Gateway                                  | Actúa como punto único de entrada para clientes, gestionando y enrutando peticiones hacia uno o varios servicios de backend.                                                                          | Simplificar y unificar el acceso a múltiples servicios. Unificar políticas de seguridad (CORS, autenticación) | Exposición directa de múltiples endpoints que dificulta el control y la seguridad.  | Implementa una capa intermedia que autentica, enruta y, en ocasiones, agrega respuestas de diversos servicios.   | Arquitecturas de microservicios que requieren una capa unificada de acceso y seguridad.                   | Sistemas con una sola API o donde la complejidad del enrutamiento es mínima. |
| Clean Architecture                           | Propone una arquitectura modular y desacoplada, donde la lógica de negocio está aislada de la infraestructura y la UI.                                                                                | Facilitar mantenibilidad, pruebas y escalabilidad.                                                            | Acoplamiento excesivo entre capas, lo que dificulta cambios y pruebas.              | Divide la aplicación en capas concéntricas (Entidades, Casos de Uso, Interfaces, Infraestructura).               | Sistemas complejos que requieren flexibilidad y evolución a largo plazo.                                  | Aplicaciones pequeñas con poca lógica de negocio.                            |

---

# Patrones de Diseño de UI/UX

### 5. Patrones de UI/UX

| Nombre            | Descripción                                                                                                                                            | Propósito                                                                     | Problema que soluciona                                                                                  | Solución                                                                                                 | Caso de uso                                                                                         | Caso de no uso                                                                                     |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| Navigation Drawer | Un panel deslizable que agrupa opciones de navegación en aplicaciones móviles y web responsivas.                                                       | Organizar y presentar menúes de forma compacta.                               | Limitaciones de espacio en interfaces móviles o adaptables.                                             | Implementar un panel que se desliza desde el lateral para mostrar opciones sin saturar la pantalla.      | Aplicaciones móviles y web donde el espacio es limitado.                                            | Si se dispone de suficiente espacio para menús fijos.                                              |
| Lazy Loading      | Carga contenido o recursos de forma diferida hasta que se necesiten, mejorando tiempos de carga y rendimiento.                                         | Optimizar la carga inicial de la interfaz y mejorar el rendimiento global.    | Largas esperas y alto consumo de recursos al cargar todo el contenido de golpe.                         | Implementar técnicas para cargar datos conforme el usuario se desplaza o interactúa.                     | Sitios web o apps con muchas imágenes, contenido o datos; la carga progresiva ayuda la experiencia. | En interfaces con muy poco contenido donde la carga no afecta el rendimiento.                      |
| Breadcrumb        | Muestra la ruta de navegación que ha seguido el usuario dentro de una jerarquía, ayudando a comprender su ubicación actual y facilitando el retroceso. | Brindar contexto mediante un rastro visual de la navegación.                  | Problemas de orientación y pérdida en estructuras de navegación profundas.                              | Implementar una secuencia de enlaces que muestre el camino desde la página principal hasta la actual.    | Sitios web con estructuras jerárquicas profundas o intrincadas.                                     | Si la navegación es simple o se dispone de menús laterales visibles.                               |
| Modal Window      | Ventana emergente que interrumpe la interacción principal para mostrar información, confirmar acciones o solicitar datos.                              | Llamar poderosamente la atención sobre información crítica.                   | Necesidad de interrumpir la interacción para dar avisos o solicitar acciones sin abandonar la pantalla. | Mostrar una ventana superpuesta que impida la interacción con el resto de la interfaz hasta ser cerrada. | Formularios, confirmaciones, alertas y diálogos importantes.                                        | Si la interrupción del usuario resulta disruptiva y se puede mostrar la información de otra forma. |
| Infinite Scroll   | Carga contenido de forma continua a medida que el usuario se desplaza, evitando paginación explícita en largas listas de elementos.                    | Mejorar la experiencia de navegación en listados extensos sin interrupciones. | Paginación tradicional que interrumpe la fluidez de la navegación.                                      | Implementar la carga dinámica de contenido cuando el usuario alcanza el final de la página visible.      | Redes sociales, feeds de noticias o galerías con grandes volúmenes de contenido.                    | Si se requiere control explícito sobre la paginación o la cantidad de contenidos mostrados.        |

---
Para mas informacion puede visitar:
[Refactoring Guru](https://refactoring.guru/)
